/*
 Copyright Â© OnePub IP Pty Ltd. S. Brett Sutton.
 All Rights Reserved.

 GPL terms per repo license.
*/

import 'dart:io';
import 'dart:typed_data';

import 'package:dcli_core/dcli_core.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:image/image.dart' as img;

import 'hmb_image_cache.dart';
import 'image_cache_config.dart';

/// We support both WebP (general) and JPEG (pdf/thumb).
/// This isolates CPU work to avoid jank.
class ImageCompressor {
  CompressJob job;

  ImageCompressor({required this.job});

  static Future<CompressResult> run(CompressJob job) async {
    try {
      final src = job.srcPath;
      if (!exists(src)) {
        return CompressResult('Source not found', success: false);
      }
      final srcBytes = await File(src).readAsBytes();

      switch (job.variant.variant) {
        case ImageVariant.general:
          // WebP, long edge resize, keep EXIF/orientation
          final out = await FlutterImageCompress.compressWithList(
            srcBytes,
            minWidth: ImageCacheConfig.generalLongEdge,
            minHeight: ImageCacheConfig.generalLongEdge,
            format: CompressFormat.webp,
            quality: ImageCacheConfig.generalWebpQuality,
            keepExif: ImageCacheConfig.generalKeepExif,
          );
          await File(job.variant.cacheStoragePath)
              .create(recursive: true)
              .then(
                (f) => f.writeAsBytes(Uint8List.fromList(out), flush: true),
              );
          return CompressResult(null, success: true);

        case ImageVariant.pdf:
          // JPEG, long edge resize. We rely on `image` for precise control.
          final decoded = img.decodeImage(srcBytes);
          if (decoded == null) {
            return CompressResult('Decode failed', success: false);
          }
          final resized = img.copyResize(
            decoded,
            width: decoded.width >= decoded.height
                ? ImageCacheConfig.pdfLongEdge
                : null,
            height: decoded.height > decoded.width
                ? ImageCacheConfig.pdfLongEdge
                : null,
            interpolation: img.Interpolation.average,
          );
          final jpg = img.encodeJpg(
            resized,
            quality: ImageCacheConfig.pdfJpegQuality,
          );
          await File(job.variant.cacheStoragePath)
              .create(recursive: true)
              .then((f) => f.writeAsBytes(jpg, flush: true));
          return CompressResult(null, success: true);

        case ImageVariant.thumb:
          // Tiny JPEG, fixed 200x200 crop/fit keeping aspect.
          final decoded = img.decodeImage(srcBytes);
          if (decoded == null) {
            return CompressResult('Decode failed', success: false);
          }
          final resized = img.copyResize(
            decoded,
            width: ImageCacheConfig.thumbWidth,
            height: ImageCacheConfig.thumbHeight,
          );
          final jpg = img.encodeJpg(
            resized,
            quality: ImageCacheConfig.thumbJpegQuality,
          );
          await File(job.variant.cacheStoragePath)
              .create(recursive: true)
              .then((f) => f.writeAsBytes(jpg, flush: true));
          return CompressResult(null, success: true);

        case ImageVariant.raw:
          // Raw is pass-through; we don't generate it here.
          return CompressResult('RAW not generated by job', success: false);
      }
    } catch (e) {
      return CompressResult('$e', success: false);
    }
  }
}
