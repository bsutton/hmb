/*
 Copyright Â© OnePub IP Pty Ltd. S. Brett Sutton.
 All Rights Reserved.

 GPL terms per repo license.
*/

import 'dart:io';
import 'dart:typed_data';

import 'package:dcli_core/dcli_core.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:image/image.dart' as img;

import 'hmb_image_cache.dart';
import 'image_cache_config.dart';

/// Generates cached image variants from original photos.
///
/// What we compress:
/// - general: WebP for on-screen display (good quality at smaller size).
/// - pdf/thumb: JPEG for predictable embedding and thumbnails.
/// - raw: pass-through; raw variants are never generated here.
///
/// Why we compress:
/// - Reduce storage and bandwidth for frequently accessed variants.
/// - Provide consistent sizing/quality across the app and PDF exports.
/// - Offload CPU-heavy work from the UI thread.
///
/// How we compress:
/// - `general` uses `flutter_image_compress` with WebP and a long-edge resize.
/// - `pdf` and `thumb` use the `image` package for deterministic JPEG output.
/// - Output is written to the variant cache path on disk.
class ImageCompressor {
  CompressJob job;

  ImageCompressor({required this.job});

  static Future<CompressResult> run(CompressJob job) async {
    try {
      final src = job.srcPath;
      if (!exists(src)) {
        return CompressResult('Source not found', success: false);
      }
      final srcBytes = await File(src).readAsBytes();

      switch (job.variant.variant) {
        case ImageVariantType.general:
          // WebP, long edge resize, keep EXIF/orientation
          final out = await FlutterImageCompress.compressWithList(
            srcBytes,
            minWidth: ImageCacheConfig.generalLongEdge,
            minHeight: ImageCacheConfig.generalLongEdge,
            format: CompressFormat.webp,
            quality: ImageCacheConfig.generalWebpQuality,
            keepExif: ImageCacheConfig.generalKeepExif,
          );
          await File(job.targetPath)
              .create(recursive: true)
              .then(
                (f) => f.writeAsBytes(Uint8List.fromList(out), flush: true),
              );
          return CompressResult(null, success: true);

        case ImageVariantType.pdf:
          // JPEG, long edge resize. We rely on `image` for precise control.
          final decoded = img.decodeImage(srcBytes);
          if (decoded == null) {
            return CompressResult('Decode failed', success: false);
          }
          final resized = img.copyResize(
            decoded,
            width: decoded.width >= decoded.height
                ? ImageCacheConfig.pdfLongEdge
                : null,
            height: decoded.height > decoded.width
                ? ImageCacheConfig.pdfLongEdge
                : null,
            interpolation: img.Interpolation.average,
          );
          final jpg = img.encodeJpg(
            resized,
            quality: ImageCacheConfig.pdfJpegQuality,
          );
          await File(job.targetPath)
              .create(recursive: true)
              .then((f) => f.writeAsBytes(jpg, flush: true));
          return CompressResult(null, success: true);

        case ImageVariantType.thumb:
          // Tiny JPEG, fixed 200x200 crop/fit keeping aspect.
          final decoded = img.decodeImage(srcBytes);
          if (decoded == null) {
            return CompressResult('Decode failed', success: false);
          }
          final resized = img.copyResize(
            decoded,
            width: ImageCacheConfig.thumbWidth,
            height: ImageCacheConfig.thumbHeight,
          );
          final jpg = img.encodeJpg(
            resized,
            quality: ImageCacheConfig.thumbJpegQuality,
          );
          await File(job.targetPath)
              .create(recursive: true)
              .then((f) => f.writeAsBytes(jpg, flush: true));
          return CompressResult(null, success: true);

        case ImageVariantType.raw:
          // Raw is pass-through; we don't generate it here.
          return CompressResult('RAW not generated by job', success: false);
      }
    } catch (e) {
      return CompressResult('$e', success: false);
    }
  }
}
